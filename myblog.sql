/*
Navicat MySQL Data Transfer

Source Server         : myblog
Source Server Version : 50617
Source Host           : localhost:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50617
File Encoding         : 65001

Date: 2016-02-24 15:40:50
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(8) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(20) NOT NULL,
  `content` longtext NOT NULL,
  `time` char(14) NOT NULL COMMENT '时间',
  `category` int(3) unsigned zerofill NOT NULL COMMENT '分类ID',
  `support` int(8) NOT NULL COMMENT '点赞数',
  `comments` int(3) unsigned NOT NULL,
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', 'CSS中的margin外边距折叠', ' CSS中的margin外边距重叠(Collapsing margins)指的是毗邻的两个或多个外边距会合并成一个外边距。其中所说的margin毗邻，可以归结为以下两点：\r\n\r\n   (1)这两个或多个外边距没有被非空内容、padding、border或clear分隔开。\r\n\r\n   (2)这些margin都处于普通流中，浮动元素、inline-block元素、绝对定位元素的margin不会和垂直方向上其他的margin元素重叠。\r\n\r\n   (3)只有垂直方向的margin才会折叠，水平方向的margin不会发生折叠的现象。\r\n\r\n   margin折叠现象的最终效果可根据计算得来，其计算方法共有如下几种：\r\n\r\n   (1)参与折叠的margin都是正值\r\n\r\n   例子：\r\n\r\n<div style=\"height:50px; margin-bottom:50px; width:50px; background-color: red;\">A</div>\r\n<div style=\"height:50px; margin-top:100px; width:50px; background-color: green;\">B</div>\r\n   示意图：\r\n\r\nmargin均为正的折叠\r\n\r\n图1：margin均为正的折叠\r\n\r\n   在margin都是正数的情况下，取其中较大的值为最终margin值。如上图1，100px和50px，都是正数，其中最大的是100px，所以取100px作为最终margin值。\r\n\r\n   (2)参与折叠的margin都是负值\r\n\r\n   当margin值都是负值的时候，取的是其中绝对值较大的，然后，从0位置，负向位移。\r\n\r\n   示例代码：\r\n\r\n<div style=\"height:100px; margin-bottom:-75px; width:100px; background-color: red;\">A</div>\r\n<div style=\"height:100px; margin-top:-50px; margin-left:50px; width:100px; background-color: green;\">B</div>\r\n   示意图：\r\n\r\nmargin均为负的折叠\r\n\r\n图2：margin均为负的折叠\r\n\r\n   如上图2，两个负数的绝对值中最大的是75，那么就取-75px，从0开始，负向位移75px。\r\n\r\n   (3)参与折叠的margin中有正值、有负值\r\n\r\n   如果，毗邻的margin中有正值，也有负值，那么先取出负margin中绝对值最大的，然后和正margin中最大的margin相加。\r\n\r\n   示例代码：\r\n\r\n<div style=\"height:50px; margin-bottom:-50px; width:50px; background-color: red;\">A</div>\r\n<div style=\"height:50px; margin-top:100px; width:50px; background-color: green;\">B</div>\r\n   示意图：\r\n\r\nmargin有正、有负的折叠\r\n\r\n图3：margin有正、有负的折叠\r\n\r\n   如上图3，先取出负数中绝对值最大的，就一个负数-50，所以负数取-50；然后取正数中最大的，就一个正数100，所以正数取100。最后，正负相加：100 + (-50) = 50，所以最终margin的值是50px。', '2016-02-02', '003', '2', '0', '0');
INSERT INTO `article` VALUES ('2', 'Github的利弊分析', '一、好的地方：\r\nGitHub是一个非常万能的工具。对于任何大小的项目，他都是理想的工具；他也是伟大的web工作流工具。首先，他可以作为一个版本控制系统和协作工具，用它来发布工作\r\n。\r\n利用GitHub，你可以将项目存档，与其他人分享交流，并让其他开发者帮助你一起完成这个项目。优点在于，他支持多人共同完成一个项目，因此你们可以在同一页面对话交流。\r\n创建自己的项目，并备份，代码不需要保存在本地或者服务器，GitHub做得非常理想。\r\n学习Git也有很多好处。他被视为一个预先维护过程，你可以按自己的需要恢复、提交出现问题,或者您需要恢复任何形式的代码，可以避免很多麻烦。Git最好的特性之一是能够跟踪错误，这让使用Github变得更加简单。Bugs可以公开，你可以通过Github评论，提交错误。\r\n在GitHub页面，你可以直接开始，而不需要设置主机或者DNS。\r\n二、欠缺的地方：\r\n如果，你是Github使用新手，首先的挑战就是摆正心态——需要不断实践和时间。\r\n他可能不是捕捉创意过程和记录创意点子的最佳工具。对于这种特殊功能模拟可以选择LayerVault 或其他相似工具。之前，我们已经强调过Github非常适用代码跟踪，但是却不是最好的设计跟踪工具。将图片内容转化为代码，或者将设计用于产品设置，看起来依旧不是那样顺利。\r\n这是由设计者决定的，然而，一些人发现 GUI 有点混乱，选择CLI代替。一些开发人员学习主要使用Git命令，这样可以解释为什么他们不太喜欢GUI的原因了。稍加练习,命令的学习是不太困难的。然而，你喜欢天天写命令吗？特别是跟踪项目历史或解决冲突的时候。所以就有了另外一群喜欢GUI的人们。将提交、修改、移动文件等操作可视化，会有一个更好的体验。而这些，就如之前提到的，需要时间来适应。\r\n如果，你专门在GIthub上工作，版本控制存储库就值得你拥有，也需要你长期付出。\r\n三、总结：\r\n总而言之，Github是一个很棒的版本控制系统。他绝对值得花时间或者投资，对于任何项目，他可以给你平和的心态和很高的灵活性。\r\n\r\n整体上来看，Git对于需要写代码的人们来说相当实用，给任何开发人员或编码器很多价值。比起Github平台，你还能找到什么更好的方式吗？而且他的价格也比较合理。\r\n\r\n现在，你已经大致了解了Github的利弊，我们希望他可以帮助你发现并理解他的价值。', '2016-02-02', '005', '5', '0', '0');
INSERT INTO `article` VALUES ('3', 'css3属性border-radius', 'CSS3属性之一：border-radius\r\n语法：\r\n\r\nborder-radius ： none | <length>{1,4} [ / <length>{1,4} ]?\r\n\r\n相关属性： border-top-right-radius , border-bottom-right-radius , border-bottom-left-radius , border-top-left-radius\r\n\r\n取值：\r\n\r\n<length>：\r\n由浮点数字和单位标识符组成的长度值。不可为负值。\r\nborder-top-left-radius：\r\n由浮点数字和单位标识符组成的长度值。不可为负值。 \r\n说明：\r\n\r\n第一个值是水平半径。\r\n如果第二个值省略，则它等于第一个值，这时这个角就是一个四分之一圆角。\r\n如果任意一个值为0，则这个角是矩形，不会是圆的。\r\n值不允许是负值。\r\ncss3属性border-radius（css3圆角）\r\n\r\n让IE支持圆角\r\n\r\n今天网上看到了一个让IE实现css3中的border-radius（圆角）:\r\n\r\n.box-radius {\r\nborder-radius: 15px;\r\nbehavior: url(border-radius.htc);\r\n}\r\n下载htc文件（源码来自）：http://code.google.com/p/curved-corner/\r\n\r\n注意：htc文件是要放在服务器上，放在本地测试是不行的！', '2016-02-03', '003', '3', '0', '../uploadimg/1456299244.jpeg');
INSERT INTO `article` VALUES ('4', 'JavaScript面向对象', '对象，是javascript中非常重要的一个梗，是否能透彻的理解它直接关系到你对整个javascript体系的基础理解，说白了，javascript就是一群对象在搅。。（哔！）。\r\n\r\n常用的几种对象创建模式\r\n\r\n使用new关键字创建\r\n\r\n最基础的对象创建方式，无非就是和其他多数语言一样说的一样：没对象，你new一个呀！\r\n\r\nvar gf = new Object(); gf.name = \"tangwei\"; gf.bar = \"c++\"; gf.sayWhat = function() { console.log(this.name + \"said:love you forever\"); }\r\n使用字面量创建\r\n\r\n这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式：\r\n\r\nvar gf = { name : \"tangwei\", bar : \"c++\", sayWhat : function() { console.log(this.name + \"said:love you forever\"); } }\r\n工厂模式\r\n\r\n实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！\r\n\r\nfunction createGf(name, bar) { var o = new Object(); o.name = name; o.bar = bar; o.sayWhat = function() { alert(this.name + \"said:love you forever\"); } return o; } var gf1 = createGf(\"bingbing\",\"d\"); var gf2 = createGf(\"mimi\",\"a\");\r\n构造函数\r\n\r\n工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式：\r\n\r\nfunction Gf(name,bar){ this.name = name; this.bar = bar; this.sayWhat = function(){ alert(this.name + \"said:love you forever\"); } } var gf1 = new Gf(\"vivian\",\"f\"); var gf2 = new Gf(\"vivian2\",\"f\");\r\n这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。\r\n上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：\r\n\r\nconsole.log(gf1.sayWhat == gf2.sayWhat); //false\r\n调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：\r\nfunction Gf(name,bar){ this.name = name; this.bar = bar; this.sayWhat = sayWhat } function sayWhat(){ alert(this.name + \"said:love you forever\"); }\r\n这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。\r\n\r\n原型对象模式\r\n\r\n理解原型对象\r\n\r\n当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。\r\n\r\n在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：\r\n\r\nfunction Gf(){ Gf.prototype.name = \"vivian\"; Gf.prototype.bar = \"c++\"; Gf.prototype.sayWhat = function(){ alert(this.name + \"said:love you forever\"); } } var gf1 = new Gf(); gf1.sayWhat(); var gf2 = new Gf();\r\n和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程：\r\n\r\n所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。\r\n\r\n使用原型对象\r\n\r\n在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下：\r\n\r\nfunction Gf(){} Gf.prototype = { name : \"vivian\", bar : \"c++\", sayWhat : function(){ alert(this.name + \"said:love you forever\"); } }\r\n这里有一个地方需要特别注意下，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:\r\n\r\nvar gf1 = new Gf(); console.log(gf1.constructor == Gf);//false console.log(gf1.constructor == Object)//true\r\n一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：\r\n\r\nGf.prototype = { constructor : Gf, name : \"vivian\", bar : \"c++\", sayWhat : function() { alert(this.name + \"said:love you forever\"); } } var gf1 = new Gf(); console.log(gf1.constructor == Gf);//true\r\n通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。\r\n\r\n构造函数和原型组合模式\r\n\r\n在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。\r\n\r\nfunction Gf(name,bar){ this.name = name; this.bar = bar; } Gf.prototype = { constructor : Gf, sayWhat : function() { alert(this.name + \"said:love you forever\"); } } var gf1 = new Gf(\"vivian\", \"f\"); var gf2 = new Gf(\"vivian1\", \"c\");\r\n在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多JS库（bootstrap等）默认的采用的模式。', '2016-02-04', '003', '3', '0', '../uploadimg/1456299375.jpg');
INSERT INTO `article` VALUES ('5', 'GET和POST的区别', 'Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.\r\n\r\n我们看看GET和POST的区别\r\n\r\n1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.\r\n\r\n2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.\r\n\r\n3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。\r\n\r\n4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.\r\n\r\npost和get的数据大小\r\n\r\n(1).首先是\"GET方式提交的数据最多只能是1024字节\"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。\r\n\r\n注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。\r\n\r\n(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。\r\n\r\n对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。\r\n\r\n由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：\r\n\r\n1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。\r\n2).IIS 6.0默认上传文件的最大大小是4MB。\r\n3).IIS 6.0默认最大请求头是16KB。\r\nIIS 6.0之前没有这些限制。[见参考资料5]\r\n\r\n所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。', '2016-02-06', '003', '2', '0', '0');
INSERT INTO `article` VALUES ('6', '没有苦劳,只有功劳!', '很多人常常发出这样的感慨：“我在公司这么多年了，没有功劳也有苦劳啊！怎么这么久还没有被提拔，薪水没有得到提升呢？”\r\n  古罗马皇帝拿破仑曾经碰到过这样一个事情。他有一个手下，跟随自己长年征战。有一次，这位属下觉得他应该得到提升。有一天这个士官找到拿破仑说，将军，我已经跟你打仗，东奔西走10年了，还是个上士啊，您应该给我提职了，拿破仑斜了一眼士官说：“你看到那头驴子了么，它跟我东奔西走20年了，可还是一头驴子！”\r\n  职场也是一样，职场当中没有苦劳，只有功劳。经验与资历固然重要，但这并不是衡量能力的标准。有些人十年的经验，只不过是一年的经验重复十次而已。年复一年的重复类似的工作，固然很熟练，但可怕的就是这种重复已然阻碍了心灵的成长，扼杀了想象力与创造力。\r\n     员工的成长有一个过程，也必须经历一定的“台阶”。如果只讲资历不看能力，就会出现论资排辈的现象。但有的人常常对此熟视无睹，结果害人不利己。因为长江后浪推前浪，有时资历无法代表全部。\r\n    不问过程怎样，只求结果如愿。作为员工，我们无须问自己为企业做了什么，而是应该问做好了什么。一字之差，折射的是员工的心态偏差和能力上的不足。只做了工作而未做好的员工很难在工作上有所建树，也就很难取得高收入。不管你工作多么奔波辛劳，如果最终没有作出业绩，你一切的辛苦和付出都是白费，你作为员工的价值就值得怀疑。有苦劳的人只重视自己付出多少，从小的方面说，是对自我人力的浪费；往大的方面说，是对企业资源的挥霍，是工作能力的缺失。\r\n     日趋复杂的经济环境，没有多少时间让我们去浪费，只有不断为企业作出实质贡献，企业才会有好的发展，因为市场经济只认结果，员工多一份“功”，企业就多一份生机，企业多一份生机，员工才能有更广阔的自我提升空间。\r\n     不重过程重结果，不重苦劳重功劳。一些成功的企业正是秉持这一理念，才由小到大、由大到强。员工价值的提升也是如此。\r\n     下班前，老总让小张写一份发言稿和一篇行业动态分析，第二天开董事会要用。虽然那个行业动态分析报告对小张来说也是个新的课题。他觉得那么短的时间里自己是不可能完成任务的。\r\n     但作为老总的秘书，小张又不得不硬着头皮去完成老总交给他的工作。他把历年来公司的资料汇总，然后把跟公司有业务来往的企业也分门别类。花了三个多小时进行研究分析，到真正动笔的时候已经是凌晨4点多了。到了这个时候，他又困又累，但为了完成任务，他还是强打精神，在电脑上一个字一个字地敲。但直到上班时间，小张的文件还没完全出来，老总过来问他写完了没有。小张无言以对。老总没说什么，只是拍拍他的肩说等会儿开会让他做好记录。\r\n     会后，老总把小张叫到办公室说，因为小张没有按时完成任务，致使此次会议没有取得预想的效果，决定扣发他的季度奖金，还把他调到下级部门，算是对小张的一次警告。\r\n     小张解释说自己是没有完成任务，但没有功劳也有苦劳啊，在别人休息、吃饭、睡觉的时间里，他都一个人在查资料、写文件。老总对他说，公司要的是结果，不是要你闷在那里苦熬，没有结果就等于没做。不但没有做，还会给公司造成损失。\r\n     现在有些像小张一样，总是以“没有功劳也有苦劳”来搪塞自己各方面能力的缺失，这是一种典型的职场“精神胜利法”。苦劳而无功其实也是一种过错，因为老板雇用员工不是要他们的做事过程，而是要他们为公司“建功立业”，作出业绩。尤其是在讲求效能、追求效率的市场经济时代，企业更需要好的结果来应对市场的变化。\r\n    市场不会给企业留下太多时间去修正、去调整；也不会说，这次你已经很努力了，也很辛苦，虽然没有功劳，也有苦劳，下次努力就是。等下次你努力的时候，别的企业早就占领了市场，主导了市场。正因为如此，现在的企业都有一种如履薄冰的危机感，这促使企业要求员工的所有工作都能一次见成效，而不是每天以“劳累之命”求“未结之果”。\r\n     张平被老板派到西郊水产市场，对市场上销售的带鱼、鱿鱼、马鲛鱼这三种海鱼的价格进行一番调查，以此来指导公司的定价策略。张平到了市场后，不仅按照老板的要求对三种鱼类的价格进行了了解，还按照不同的规格和包装进行了价格分类。他还向摊主询问了每天的销售情况，以及对改变进货渠道的兴趣。\r\n     回到公司后，他没有马上去见老板，而是花了10分钟快速地做了一个统计表，这样，老板拿到手中所有的数据都能一目了然。老板对张平的工作很满意，很快给他加了薪水，并让他搬到四人间的办公室。老板的这些奖励措施并不是因为张平的这次表现，而是对他长久以来的工作的肯定。\r\n     若想像张平这样脱颖而出并非难事，你要做的就是以企业所要达到的目标为一切工作的出发点，积极思考，高效率的完成工作任务，这不仅能使企业实现最大的效益，员工也能在“劳而有功”的情况下，快速提升自己的职位，从而拥有完美的职业人生。\r\n     俗话说：革命不分先后，功劳却有大小。企业需要的是能够解决问题、勤奋工作的员工，而不是那些曾经做出过一定贡献，现在却跟不上企业发展步伐，且自以为是的员工。在一个凭实力说话的年代，讲究能者上庸者下，没有哪个老板愿意拿钱去养一些无用的闲人。一句话，不重苦劳重功劳，强调的是企业的诉求——企业要的是结果而不是过程。即使你付出了千倍努力，吃尽了苦头，如果你没有为企业作出业绩，对企业的贡献为零，你的工作就是无用功。\r\n   1993年，郭士纳就任IBM公司董事长和首席执行官。这是IMB第一次从本公司员工外挑选一个领导人。而郭士纳上任之际正是IBM亏损惨重、即将分崩离析之时。\r\n    郭士纳上任之后，他的改革措施之一就是裁员。他在一份备忘录中说出了自己的肺腑之言：“你们中有些人多年效忠于公司，到头来反被宣布为‘冗民’，报刊上也登载了一些业绩评分的报道，当然会让你们伤心愤怒。我深切感到自己是在要大量裁员的痛苦之时上任的，我知道这对大家都是痛苦的，但大家都知道这也是必要的。”\r\n     不解雇政策是IBM企业文化的主要支柱，公司创始人托马斯•沃森及其儿子小沃森认为，这样可以让每个员工觉得安全可靠。如今，郭士纳裁员却动了大手术，一口气就裁减35000名员工。\r\n     裁员行动结束后，郭士纳对留下来的雇员说：“有些人总是抱怨，自己为公司工作多年，薪水太少了，职位升迁太慢。你必须拿出点成绩让我看看，得给我创造出成大的效益。现在你是否继续留任，就看你的表现了。”\r\n     通过一系列的治理整顿和改革，郭士纳在短短的六年中重塑了IBM这个曾是传奇偶像企业的美好形象，使之走上了重新增长的复兴之路。\r\n     职场中辞退员工是经常见到的事情，有些人已经是处变不惊了。但有一个道理我们必须清楚：公司作为一个经营实体，必须靠利润去维持发展，而要发展便需要公司中的每个员工都贡献自己的力量和才智。公司是员工努力证明自己业绩的战场，证明自己的唯一法则就是业绩。无论何时何地，如果你没有作出业绩，你迟早是一枚被弃用的棋子。\r\n     通常来说，一个成功老板的背后必定有一群能力卓越，业绩突出的员工。老板心中分数很高的职员，也一定是那些业绩斐然的员工，当然，他们将获得丰厚的奖赏，而业绩差的员工，则随时会有被老板解雇的可能。\r\n     身在职场，必须懂得“没有苦劳，只有功劳”是员工在公司的生存哲学。（摘自《成为企业最需要的人》）', '2016-02-07', '007', '2', '0', '0');
INSERT INTO `article` VALUES ('7', '博客的意义，分享和学习共存', '2013-2014两年期间，博客断断续续的写着自己的文章，花费的时间很多，一直也主张原创内容，全部基于个人兴趣，不追求seo，不放广告，不拉赞助，不看流量。而今想想，是多么的幼稚和纯真的时候。今年博客，不再是记录个人网站记录，也将分享其他知名博客的好文章，博采众长，扩宽自己的知识体系和技术深度。只要是自己有所得，想要和大家分享或者给自己做一个备忘的东西，都可以记录下来。\r\n\r\n每天坚持做一件事很难\r\n\r\n毕业两年以来，虽说学习的技术也挺多的，但是还是跟别人有一定的差距，开了一个微博，关注了一些技术牛人和技术资料社区，每天都有许多的人发表许多令人叹为观止的文章，所以我创建了一个前端日报（最近工作忙，无暇顾及）和前端周刊来拓宽自己的视野，同时也方便别人。同时也感受到了一个人要每天坚持做一件事，做好一件事是多么的不容易啊。\r\n\r\n原创文章的时间和代价巨大\r\n\r\n随着时间的分散和要做的内容增加，要发表一篇优秀的原创文章是要花费很多的时间，来，我们来计算一下。首先，找相关资料花费半个小时；编写代码案例半个小时；将代码实现思路和相关资料结合写成文章半个小时至1个小时，这样子算下来，下班回家，写一篇文章基本就没有时间做其他事了。\r\n\r\n分享技术，思考启发\r\n\r\n如果每天都写一篇文章，那样子的日子是非常糟糕的，想要学习其他内容的就很少了。所以我将逐步减少关注博客原创，更多的分享一些优秀的文章和翻译一些国外的技术文章，思考一下别人写过的文章给自己带来的启示和帮助。静下心来看一些技术书籍，提升自己的技术深度和扩宽自己的技术领域。\r\n\r\n待时而动，希望能够进入一个复杂的业务公司，通过工作突破目前的低迷状态。', '2016-02-08', '007', '3', '0', '0');
INSERT INTO `article` VALUES ('8', 'Unicode详解', '上个月，我做了一次分享，详细介绍了Unicode字符集，以及JavaScript语言对它的支持。下面就是这次分享的讲稿。\r\n\r\n一、Unicode是什么？\r\nUnicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。\r\n目前，Unicode的最新版本是7.0版，一共收入了109449个符号，其中的中日韩文字为74500个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文\"好\"的码点是十六进制的597D。\r\n二、UTF-32与UTF-8\r\nUnicode只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。\r\nUTF-32的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。\r\n人们真正需要的是一种节省空间的编码方法，这导致了UTF-8的诞生。UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。\r\n由于UTF-8这种节省空间的特性，导致它成为互联网上最常见的网页编码。不过，它跟今天的主题关系不大，我就不深入了，具体的转码方法，可以参考我多年前写的《字符编码笔记》。\r\n三、UTF-16简介\r\nUTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。\r\n它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。\r\n于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？\r\n说来很巧妙，我也不知道是不是故意的设计，在基本平面内，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。\r\n具体来说，辅助平面的字符位共有220个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小210），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。\r\n所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。\r\n四、UTF-16的转码公式\r\nUnicode码点转成UTF-16的时候，首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。\r\n五、JavaScript使用哪一种编码？\r\nJavaScript语言采用Unicode字符集，但是只支持一种编码方法。\r\n这种编码既不是UTF-16，也不是UTF-8，更不是UTF-32。上面那些编码方法，JavaScript都不用。\r\nJavaScript用的是UCS-2！\r\n六、UCS-2编码\r\n怎么突然杀出一个UCS-2？这就需要讲一点历史。\r\n互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是1988年成立的UCS团队，另一个是1989年成立的Unicode团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。\r\n1991年10月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是Unicode，并且修订此前发布的字符集，UCS的码点将与Unicode完全一致。\r\nUCS的开发进度快于Unicode，1990年就公布了第一套编码方法UCS-2，使用2个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以2个字节就够用了。）UTF-16编码迟至1996年7月才公布，明确宣布是UCS-2的超集，即基本平面字符沿用UCS-2编码，辅助平面字符定义了4个字节的表示方法。\r\n两者的关系简单说，就是UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。所以，现在只有UTF-16，没有UCS-2。', '2016-02-09', '007', '4', '0', '0');
INSERT INTO `article` VALUES ('9', 'CSS代码实现背景透明文字不透明', '按照以前的写法是使用两个元素来控制，一个写背景透明、一个写文字。然后通过定位：absolute和层级：z-index来控制。现在我们可以通过如下方法使用一个元素来控制：\r\n\r\n在 FF/Chrome 等较新的浏览器中可以使用css属性background-color的rgba轻松实现背景透明，而文字保持不透明。而IE6/7/8浏览器不支持rgba，只有使用IE的专属特性filter:属性来制作透明背景。\r\n\r\n.caibaojian{\r\n     -ms-filter: \"progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=#80000000,endColorstr=#80000000)\"; /*Filter for IE8 */    \r\n     filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=#80000000, endColorstr=#80000000); /*Filter for older IEs */}\r\n:root .caibaojian{\r\nfilter:none;/*IE9不需要filter*/\r\nbackground:#000;\r\nbackground: rgba(0, 0, 0,0.5);\r\n}\r\n这里需要注意的是startColorStr和endColorStr的值#80000000,其中前两位是十六进制的透明度80,也就是透明值为0.5而后面六位是十六进制的颜色#000000(black黑色)。', '2016-02-10', '003', '5', '0', '../uploadimg/1456299120.jpg');
INSERT INTO `article` VALUES ('10', 'Linux平台下7个实用的软件', '很多人都在不同的平台使用很多商业软件来完成不同的工作，这其实是非常不方便的，因为有时这些软件也并不好购买。今天在本文中，小编为大家列出了7个Linux平台下非常有用的软件，这其中大部分都是跨平台的。还有其他一些适用单一的软件，但今天只列出了一些非常相似的可替代的软件。不想错过这些不错的软件？那你还在等什么，还不赶紧一起来看看！\r\n\r\nOpenProj\r\n\r\nLinux平台下7个实用的软件\r\n\r\nOpenProj是一款免费并且开源的桌面应用，用于替代到微软的项目中。OpenProj为桌面应用项目的管理人员提供了完美的解决方案，并且它在Unix，Linux，Windows甚至是Mac上都是相当可靠的。它是所有微软项目桌面应用的替代品，甚至可以打开本地的项目文件。它分享了业界许多基于项目需求的高质量的时间调度引擎。该方案具有成本核算，网络图(PERT图)，Gantt图表，RBS、WBS报表，等等。\r\n\r\nBluefish\r\n\r\nLinux平台下7个实用的软件\r\n\r\nBluefish是一款为熟练Web设计人员和程序员而设的编辑器，任何初学者也都能够很快上手，并且在不断地积累中发现和掌握它的其他功能。它拥有很多的选项，可以写网站、脚本以及编程代码。Bluefish支持多种编程和标记语言，专注于编辑动态和交互式网站。\r\n\r\nDia\r\n\r\nLinux平台下7个实用的软件\r\n\r\nDia是基于GTK的图形绘制程序，适用于Linux, Unix和Window，以 GPL 许可发布。Dia是开放源码的流程图软件，它将多种需求以模组化来设计，如流程图、网络图、电路图等。各模组之间的符号仍是可以通用的，并没有限制。Dia可以画多种示意图，并且借由XML可以新增多种图形。Dia使用dia（自有格式）或XML格式（默认以gzip压缩节省空间）加载及储存流程图。有些用户认为Dia的很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。\r\n\r\nCinePaint\r\n\r\nLinux平台下7个实用的软件\r\n\r\nCinePaint是一个开源的类似于Photoshop的图形制作和处理软件，目的是为了满足Linux下图像制作和处理方面所谓DP（Deep Paint）的需求。CinePaint能够打开高保真的图像文件格式和传统的格式，同时它支持8位、16位和32位的color channels、HDR和CMS。\r\n\r\nKSpreadÂ\r\n\r\nLinux平台下7个实用的软件\r\n\r\n\r\n \r\n通过KSpread可以创建面向表的表信息和强大的计算，同时KSpreadA拥有一个巨大的可用公式列表，允许所有的预期数值、文本特征等预计在一个电子表格中。\r\n\r\nKMyMoney\r\n\r\nLinux平台下7个实用的软件\r\n\r\nKMyMoney是一款为 KDE 桌面而筹办的全体理财管理软件。它经由提供丰富的理财功效和东西来搀扶帮助人们跟踪本人的资金流，以便对其全体工业举行有效地管理。KMyMoney非常适合非技术人员运用，同时它的功能非常丰富。\r\n\r\nGuarddog\r\n\r\nLinux平台下7个实用的软件\r\n\r\nGuarddog是Linux系统的防火墙配置实用程序。Guarddog主要是针对于两种用户，一种是新手，另一种就是中级用户，因为二者都不是TCP/ IP网络安全专家，都不能够对付神秘的shell脚本和的ipchains/ iptables的参数。', '2016-02-11', '005', '2', '0', '0');
INSERT INTO `article` VALUES ('11', '浅谈如何学习linux', '一.为什么要学linux?\r\n\r\n　　当然最重要是爱好和兴趣！如果你这种必要学，或者根本不喜欢，请不要浪费时间，你学也学不好！\r\n\r\n　　二.起步\r\n\r\n　　你应该为自己创造一个学习linux的环境--在电脑上装一个linux或unix\r\n\r\n　　如何选择版本：北美用redhat,欧洲用SuSE,桌面mandrake较多，而debian是技术最先进的linux开发人员中用debian的最多，其次是redhat,从全球linux各应用领域市场份额来看无疑redhat是最多的，此外还有很多出名的发行版本，不再列举。\r\n\r\n　　对于初学linux的人来说，我建议是使用redhat,原因如下：\r\n\r\n　　1）现在很多书都是以redhat为例讲的，为了与书本协调一致\r\n\r\n　　2）周围的人都用redhat,交流比较方便\r\n\r\n　　3）redhat应用范围广，有典型性和代表性\r\n\r\n　　4）它易于使用和安装，我们没有必要把时间浪费在“装系统”上而应集中精力学习最有用的东西。\r\n\r\n　　【注】现在觉得RH很死板，AS,ES等用在服务器上或许不错，Personal desktop用mandrake,debian,suse都不错，笔者现在用Mandrake,因为她长得漂亮:)\r\n\r\n　　如果你并不打算深入学习linux，而是有诸如适应北京市政府办公平台迁移到linux上这种需要，那么中软，红旗等中文linux是不错的选择\r\n\r\n　　我强烈建议：自己亲自动手把linux装到你的硬盘上，你必须学会独立安装linux系统的技能，对于现在的版本来说，其实跟装WinXP一样简单\r\n\r\n　　从此现在开始，请不要以windows的工作方式来考虑问题，应该尝试挖掘linux身上的“天才unix”的气质。\r\n\r\n　　三.进阶\r\n\r\n　　掌握至少50个以上的常用命令\r\n\r\n　　理解shell管道\"|\",文件流重定向\">\"及追加\">>\"等\r\n\r\n　　熟悉Gnome/KDE等X-windows桌面环境操作\r\n\r\n　　掌握.tgz.rpm.biz等软件包的常用安装方法\r\n\r\n　　学习添加外设，安装设备驱动程序（比如modem)\r\n\r\n　　熟悉Grub/Lilo引导器及简单的修复操作\r\n\r\n　　熟悉系统固有目录的名称及公用\r\n\r\n　　学会用mount命令访问其他文件系统\r\n\r\n　　了解vi,gcc,gdb等常用编辑器，编译器，调试器\r\n\r\n　　学习linux环境下的简单组网\r\n\r\n　　建议：买一本不需要太厚的linux教材，大致可以满足要求（现在的书越来越多了，还带很多图，我当时可没这么多书）\r\n\r\n　　四.高级应用\r\n\r\n　　澄清一些概念：linux的普通操作与真正的系统管理不能相提并论，后者需要很多知识\r\n\r\n　　1.英语\r\n\r\n　　即使你不学linux，我也强烈建议你学好英文[U.S.english]。因为实质上计算机语言就是英文和字符,所谓的多国语言只是外部包装。你必须能无障碍的阅读大量的英文技术文档在搜索引擎找到的英文网站和网页中熟练的检索最好能有用英文直接交流的能力，摆脱了这个障碍，你的学习和理解速度就能快很多，你就有机会拉开和别人的差距。\r\n\r\n　　2.shell[sed/awk]\r\n\r\n　　shell是命令解释器，是内核与用户界面交流通道，shell写的小脚本有点类似于win下的.bat但shell比.bat强大的多，shell不只是解释命令，更是一种编程语言，有时候几百行的c用shell几十行就能代替完成工作，因为shell的工作方式建立在系统已有的众多应用程序之上\r\n\r\n　　这也是CS中的一个重要思想。此外，shell可以实现工作自动化，这个概念也比较重要sed,awk用来处理文本，历来很常用。\r\n\r\n　　3.Perl/PHP\r\n\r\n　　漂亮的脚本， CGI的首选，比ASP好，应用面很广\r\n\r\n　　4.CC++\r\n\r\n　　C、C++是linux/unix的核心语言，系统代码都是C写的\r\n\r\n　　5.ASM\r\n\r\n　　系统底层及内核，硬件，设备驱动程序，嵌入式开发都需要。//走核心路线的话，cc++,asm最重要\r\n\r\n　　6.Java,Python,Tcl,XML\r\n\r\n　　五、系统管理篇\r\n\r\n　　在熟悉linux的基础上还需要掌握至少一种unix。我首推Solaris，其次是FreeBSD比如运营级系统一般是Solaris+Oracle/DB2之类的学习apache、ssh、sendmail/Qmail、proftp/vsftp、Samba、Squid、MySQL/PostgreSQL/Oracle、Bind等各种应用服务器的构架及电子商务的应用熟悉TCP/IP协议族，学习诸如apache+php+proftp+mysql+quota的实现以及大型局域网，分布式集群等各种企业级应用解决方案熟悉多用户管理，数据库管理，文件系统，逻辑存储管理，日志分析，备份与灾难数据修复系统补丁，内核升级，以及在此基础上的防火墙构架等以保障系统安全在内的各种系统管理技能。\r\n\r\n　　我觉得，如果在此基础上再掌握路由/交换设备便是一个不错的系统管理员\r\n\r\n　　各种基于linux的解决方案可参考相关书籍和文献，必要时用google或各大linux站点站内搜索引擎寻找最新文档，以避免错误和漏洞有几本技术大全和技术内幕我认为都是这方面不错的书\r\n\r\n　　六、深入学习linux\r\n\r\n　　我个人理解的读linux内核需要的基础：在此之前,希望先把应用层的东西学一下,那样会比较好理解\r\n\r\n　　1.C\r\n\r\n　　如果学过潭浩强的大学教科书(除了编几个数学模型好像什么也做不了的那种)，建议再看一下《The C Programming Language》Second Edition这本圣经（如果想学缓冲区溢出，这点C的功力可能是不够的，还有<C陷阱与缺陷>,<C专家编程>,<CC++深层探索>，反正经典书看多了是没有坏处的）\r\n\r\n　　2.asm (AT&T语法，保护模式)\r\n\r\n\r\n \r\n　　保护模式下的比较复杂，基本上每本讲内核的书都会有介绍有80x86 Intel语法的基础就行，\r\n\r\n　　有兴趣可以看看Intel的官方网站\r\n\r\n　　3.数据结构（离散数学）\r\n\r\n　　计算机专业的核心课程，重要性我就不说了\r\n\r\n　　4.操作系统原理\r\n\r\n　　看懂这个再去读linux吧\r\n\r\n　　5.微机原理/组成原理（数字电路）\r\n\r\n　　底层直接和硬件打交道，所以这个也要\r\n\r\n　　6.了解linux/unix\r\n\r\n　　我想至少你要会操作吧，了解unix的API\r\n\r\n　　7.软件工程/编译原理\r\n\r\n　　这方面的经典书去www.china-pub.com可以搜到很多我觉得APUE这种书不适合初学者，还是先看看UPE', '2016-02-12', '004', '2', '0', '0');
INSERT INTO `article` VALUES ('12', '跨域访问和防盗链基本原理', '一、什么是防盗链\r\n网站资源都有域的概念，浏览器加载一个站点时，首先加载这个站点的首页，一般是index.html或者index.php等。页面加载，如果仅仅是加载一个index.html页面，那么该页面里面只有文本，最终浏览器只能呈现一个文本页面。丰富的多媒体信息无法在站点上面展现。\r\n\r\n那么我们看到的各类元素丰富的网页是如何在浏览器端生成并呈现的？其实，index.html在被解析时，浏览器会识别页面源码中的img，script等标签，标签内部一般会有src属性，src属性一般是一个绝对的URL地址或者相对本域的地址。浏览器会识别各种情况，并最终得到该资源的唯一地址，加载该资源。具体的加载过程就是对该资源的URL发起一个获取数据的请求，也就是GET请求。各种丰富的资源组成整个页面，浏览器按照html语法指定的格式排列获取到各类资源，最终呈现一个完整的页面。因此一个网页是由很多次请求，获取众多资源形成的，整个浏览器在一次网页呈现中会有很多次GET请求获取各个标签下的src资源。\r\n观察其中的请求目的地址，可以发现有两类，一个是本站的43.242段的IP地址，这是本站的空间地址，即向本站自身请求资源，一般来说这个是必须的，访问资源由自身托管。另外一类是访问182的网段拉取数据。这类数据不是托管站内的，是在其他站点的。浏览器在页面呈现的过程，拉取非本站的资源，这就称“盗链”。\r\n二、跨域访问基本原理\r\n在上一篇，介绍了盗链的基本原理和防盗链的解决方案。这里更深入分析一下跨域访问。先看看跨域访问的相关原理：跨网站指令码。维基上面给出了跨站访问的危害性。从这里可以整理出跨站访问的定义：JS脚本在浏览器端发起的请求其他域（名）下的网站数据的HTTP请求。\r\n\r\n这里要与referer区分开，referer是浏览器的行为，所有浏览器发出的请求都不会存在安全风险。而由网页加载的脚本发起请求则会不可控，甚至可以截获用户数据传输到其他站点。referer方式拉取其他网站的数据也是跨域，但是这个是由浏览器请求整个资源，资源请求到后，客户端的脚本并不能操纵这份数据，只能用来呈现。但是很多时候，我们都需要发起请求到其他站点动态获取数据，并将获取到底数据进行进一步的处理，这也就是跨域访问的需求。\r\n\r\n这样即可根据客户端指定的回调拼装调用过程。\r\n\r\n2、CORS（Cross-origin resource sharing）跨域访问\r\n上述的JSONP由于有诸多限制，已经无法满足各种灵活的跨域访问请求。现在浏览器支持一种新的跨域访问机制，基于服务端控制访问权限的方式。简而言之，浏览器不再一味禁止跨域访问，而是需要检查目的站点返回的消息的头域，要检查该响应是否允许当前站点访问。通过HTTP头域的方式来通知浏览器：\r\n\r\n服务端利用这几个HTTP头域通知浏览器该资源的访问权限信息。在访问资源前，浏览器会先发出OPTIONS请求，获取这些权限信息，并比对当前站点的脚本是否有权限，然后再将实际的脚本的数据请求发出。发现权限不允许，则不会发出请求。逻辑流程图为：\r\n\r\n \r\n浏览器也可以直接将GET请求发出，数据和权限同时到达浏览器端，但是数据是否交给脚本处理需要浏览器检查权限对比后作出决定。\r\n\r\n一次具体的跨域访问的流程为：\r\n\r\n因此权限控制交给了服务端，服务端一般也会提供对资源的CORS的配置。\r\n\r\n跨域访问还有其他几种方式：本站服务端代理、跨子域时使用修改域标识等方法，但是应用场景的限制更多。目前绝大多数的跨域访问都由JSONP和CORS这两类方式组成。', '2016-02-13', '006', '3', '0', '0');
INSERT INTO `article` VALUES ('13', '关于Web安全，99%的网站都忽略了这些', 'Web安全是一个如何强调都不为过的事情，我们发现国内的众多网站都没有实现全站https，对于其他安全策略的实践更是很少，本文的目的并非讨论安全和攻击的细节，而是从策略的角度引发对安全的思考和重视。\r\n\r\n1.数据通道安全\r\nhttp协议下的网络连接都是基于明文的，信息很有可能被泄露和篡改，甚至用户都不知道通信的对方是否就是自己希望连接的服务器，因此，信息通道安全有以下两个目标：\r\n\r\n身份认证\r\n数据不被泄漏和篡改\r\n幸运的是https解决了上述问题的。\r\n理论上https是安全的，即使如此，https依然应该被重视，因为理论上理论和实践是一样的，但实践中又是另外一回事。前段时间爆发的心血漏洞就是一个例子。\r\n\r\n2.浏览器安全\r\nhttps解决了点到点的安全问题和身份认证问题，接下来会出现问题的地方就只有2个：浏览器和服务器，这个层面上的安全问题并没有https一样的银色子弹可以一次性解决。\r\n2.1 origin 源\r\n了解浏览器安全，有一个概念特别重要，那就是源(origin) 什么是源呢？\r\n相同的HOST\r\n相同的协议\r\n相同的端口\r\n举栗子\r\nhttps://www.wilddog.com 和 http://www.wilddog.com 非同源，因为协议不同。\r\nhttp://wilddog.com 和 http://www.wilddog.com非同源，因为域名不同。\r\nhttp://wilddog.com 和 http://wilddog.com:8080 非同源，因为端口不同。\r\n源这个概念为甚这么重要，这要从同源策略说起。\r\n2.2 同源策略\r\n同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。简单的说就是一个源的页面上的js只能访问当前源的资源，不能访问其他源的资源。\r\n那么资源是什么呢？\r\nDOM\r\n通过AJAX请求的网络资源\r\nCookie\r\nWebStorage，webSql\r\n…\r\n很显然，同源策略以源为单位，把资源天然分隔，保护了用户的信息安全。\r\n同源策略是一堵墙，然而墙并非不透风。有很多方法可以绕过同源策略让javascript访问其他源的资源。\r\n2.3 XSS(Cross-Site Script)\r\n\r\n跨站脚本攻击，名字跟同源策略很像，事实上他们之间基本没有关系。跨站脚本攻击本质上是一种注入攻击（有兴趣了解更多注入攻击可以看这里）。其原理，简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本。XSS的例子只要百度一下有很多。XSS能做用户使用浏览器能做的一切事情。可以看到同源策略无法保证不受XSS攻击，因为此时攻击者就在同源之内。\r\nXSS攻击从攻击的方式可以分为\r\n反射型\r\n存储型\r\n文档型\r\n这种分类方式有些过时，长久以来，人们认为XSS分类有以上三种，但实际情况中经常无法区分，所以更明确的分类方式可以分为以下两类：\r\n\r\nclient(客户端型)\r\nserver(服务端型)\r\n当一端xss代码是在服务端被插入的，那么这就是服务端型xss，同理，如果代码在客户端插入，就是客户端型xss。\r\n\r\n说了这么多我们看以下一些各个网站实现的情况。\r\n\r\n\r\n\r\n谷歌是行业的标杆，在互联网无出其右，学习Google就对了！\r\n\r\n\r\n\r\nwww.wilddog.com同样也实现了几个重要的http头。\r\n\r\n\r\n百度做的就比较差了，一家如此大规模的互联网公司，对于安全，对于技术如此不敏感，只能说是很悲哀，充分说明中国互联网企业对安全的重视是非常低的！值得注意的是，百度的http到https的跳转居然是服务端做的。\r\n\r\n我们再来看下行业笑话12306！\r\n\r\n3.HTML5 对web安全的影响\r\n\r\nhtml5带来了很多新的特性，让浏览器和javascript获得了更大的能力。然而能力越大，被攻破后的危险就越大。\r\n\r\nHTML5 对xss的影响主要体现在:\r\n\r\n\r\n \r\n更大的攻击面，html5带来来更多的标签和更多的属性，xss发生的可能性更大\r\n更大的危害，HTML5更多的资源可以被xss利用。黑客可以利用浏览器的一切权限，比如本地存储，GEO，WebSocket，Webworker。\r\n遗憾的是HTML并没有针止XSS和XSRF带来系统性解决方案。在这个前提下，CSP变得非常重要，可以大大降低XSS后的危害。\r\n\r\nHTML5时代实际对开发者提出来更高的要求，因为有更多的交互，更多的前端行为，HTML5有更多的API。希望共勉，不做蒙古大夫，与广大的开发者一同提高中国互联网的用户体验！', '2016-02-14', '006', '3', '0', '../uploadimg/1456299200.jpg');
INSERT INTO `article` VALUES ('14', '我喜欢一个人编程', '我已经在加利福尼亚科学院工作有5个月了。我正在开发一个由国家科学基金会支持的蚂蚁分类学网站：antcat.org。\r\n\r\n这是我25年的程序员工作中最好的一个。\r\n\r\n有好些理由：我工作在一个博物馆里，每天我可以四处走走观赏奇异的鱼，蜥蜴，和蝴蝶。这是一个用栅栏围住的绿区，老板聪明和善，用户都是科学家。博物馆就在金门海峡公园，距我居住的地方只有10分钟的路程。我的年薪“只有”1百万，比我好些年前的薪水都少。但他们给我医疗保险，每周我还可以去几次tidepool展览会。\r\n\r\n \r\n\r\nMark Wilden\r\nMark Wilden\r\n \r\n\r\n但这最重要的原因是我喜欢独自编程。\r\n\r\n我并没有觉得独自编程有什么特别好的。其实我喜欢工作在一个有活力和创新精神的团队里 — 甚至结对编程。但我没有选择这样。\r\n\r\n原因非常的简单，现在的工作我可以按我想要的方式进行。也就是95%的驱动测试开发。也就是敏捷开发 — 用最简单的方式完成工作。也就是我可以按照我自己的意愿在项目里使用Solr。也就是我可以真正的开始学习Javascript。也就是我可以把这些年在这个领域里积累下来的知识和经验完全应用到工程里。同时也就是我做这些事情时不需要和别争论这些事情。\r\n\r\n也许是我一直不太走运，在lean开发，敏捷开发，OOP，数据库设计，或甚至结构化编程上，我从没有遇到与我有共同思想的人。我的观念都学自于阅读Martin Fowler 和 Kent Beck等人的文章。很显然，有些理论都是这些人想当然出来的，例如避免过度优化，或遵循单一责任原则。\r\n\r\n所以在跟我的同事的接触中总是为这些事情争论不休。这么多年来我的脾气已经变得圆滑和礼貌的多了，而且在某些观点上愿意采取一种让步的态度(毕竟，也许我的观点是错误的)。可是慢慢的你会有时候厌倦了做OOP“纯粹主义者”(我不是)。有时候你只是想把事情做“好”。\r\n\r\n现在，我十分的清楚当你一个人工作的时候你失去的是什么。我做的事情常是错误的。其实有很多其它的我应该知道的方法但我一个人无从得知。毫无疑问我写出来很多bug。有时候我弄出的错误的设计浪费了我很多的时间。如果我工作在一个团队中，或者结对编程，这些全都可以避免或减少。谈到结对编程，有一个事实，我现在的工作效率没有我在Pivotal公司里结对编程时的效率高。当时我们的成绩是如此的显著，解决任务是过关斩将。唯一的问题是我不喜欢这种方式。\r\n\r\n我也知道我在赞成一种“牛仔编程者”风格的开发，这种风格的人在团队合作中确实令人头痛。但在没有团队的情况下呢？\r\n\r\n\r\n \r\n我知道人们从我们这代人中能更多的听到这种声音。这是相对于年轻的伴随着敏捷开发方法长大的年轻一代是这样的。我要说的是我在努力拥抱那些前沿的思想方法 — 1989年诞生的OOP，2000年诞生的TDD，现在的lean。这也导致了我更多的对这些东西产生了不同的观点。\r\n\r\n当然，归根结底，我深信唯一明智的判断一种行为方式的标准是看它是否能使你快乐。一个人选择去做某种事情的唯一理由是它能使你快乐(从长远的视角看)。\r\n\r\n对于我来说快乐是我的底线。', '2016-02-15', '002', '10', '0', '0');
INSERT INTO `article` VALUES ('17', '斐波那契数列算法及时间复杂度分析', '斐波那契数列是一个很有意思的数列,应用领域非常广.\r\n\r\n定义:\r\nF(n+1)=F(n)+F(n-1)\r\n有意思的是,F(n)/F(n+1)趋于黄金分割0.618.\r\n\r\n如何计算斐波那契数呢?\r\n最朴素的思想,利用定义.\r\n算法1代码如下:\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\nstatic int Fibonacci1(int n)\r\n\r\n{\r\n\r\nif (n == 1 || n == 2)\r\n\r\n{\r\n\r\nreturn 1;\r\n\r\n}\r\n\r\nreturn Fibonacci1(n - 1) + Fibonacci1(n - 2);\r\n\r\n}\r\n\r\n分析下算法复杂度:\r\nT(n+1)=T(n)+T(n-1)=2*T(n-1)+T(n-2)=…=F(n)+F(n-1)=F(n+1)\r\n由于直接递归调用,结果中的每一个1都来自最底层的F(1)和F(2),\r\n那么为了求第n个数,就要调用F(n)次函数.\r\n由于斐波那契数列是指数增长,所以该算法的时间复杂度也是指数增长,即O(2^n).\r\n\r\n仔细想下,从头开始往后算,也不过是线性复杂度,比算法1好太多了.\r\n于是得到算法2:\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\nstatic int Fibonacci2(int n)\r\n\r\n{\r\n\r\nint[] a = new int[n];\r\n\r\na[0] = 1;\r\n\r\na[1] = 1;\r\n\r\nfor (int i = 2; i < n; i++)\r\n\r\n{\r\n\r\na[i] = a[i - 1] + a[i - 2];\r\n\r\n}\r\n\r\nreturn a[n - 1];\r\n\r\n}\r\n\r\n时间复杂度就是O(n).\r\n\r\n求斐波那契数列的算法还能再快一些吗?\r\n答案是肯定的.\r\n算法3:\r\n借助下图所示的结论:\r\n利用矩阵的乘法求斐波那契数列\r\n我们求一个矩阵的n次方即可.\r\n两个2维矩阵的乘法次数可以看作常量.\r\n矩阵额n次方利用分治法,只需要O(lg n)的复杂度就能计算出来.\r\n所以该算法的复杂度是O(lg n),比算法2又快了很多,特别是数字非常大的时候.\r\n比如n从1亿变成4亿,算法2需要的时间要变成原来的四倍,但是算法3仅仅增加了个常数2(lg 4=2).\r\n算法代码如下:\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n12\r\n\r\n13\r\n\r\n14\r\n\r\n15\r\n\r\n16\r\n\r\n17\r\n\r\n18\r\n\r\n19\r\n\r\n20\r\n\r\n21\r\n\r\n22\r\n\r\n23\r\n\r\n24\r\n\r\n25\r\n\r\n26\r\n\r\n27\r\n\r\n28\r\n\r\n29\r\n\r\n30\r\n\r\n31\r\n\r\n32\r\n\r\n33\r\n\r\n34\r\n\r\n35\r\n\r\n36\r\n\r\n37\r\n\r\n38\r\n\r\nstatic int Fibonacci3(int n)\r\n\r\n{\r\n\r\nint[,] a = new int[2, 2] { { 1, 1 }, { 1, 0 } };\r\n\r\nint[,] b = MatirxClub(a, n);\r\n\r\nreturn b[1, 0];\r\n\r\n}\r\n\r\nstatic int[,] MatirxClub(int[,] a, int n)\r\n\r\n{\r\n\r\nif (n == 1) { return a; }\r\n\r\nelse if (n == 2) { return Matirx(a, a); }\r\n\r\nelse if (n % 2 == 0)\r\n\r\n{\r\n\r\nint[,] temp = MatirxClub(a, n / 2);\r\n\r\nreturn Matirx(temp, temp);\r\n\r\n}\r\n\r\nelse\r\n\r\n{\r\n\r\nint[,] temp = MatirxClub(a, n / 2);\r\n\r\nreturn Matirx(Matirx(temp, temp), a);\r\n\r\n}\r\n\r\n}\r\n\r\nstatic int[,] Matirx(int[,] a, int[,] b)\r\n\r\n{\r\n\r\nint[,] c = new int[2, 2];\r\n\r\nfor (int i = 0; i < 2; i++)\r\n\r\n{\r\n\r\nfor (int j = 0; j < 2; j++)\r\n\r\n{\r\n\r\nfor (int k = 0; k < 2; k++)\r\n\r\n{\r\n\r\nc[i, j] += a[i, k] * b[k, j];\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\nreturn c;\r\n\r\n}\r\n\r\n随手写了个测试程序对比它们的效率.\r\n算法1计算n=42和算法2计算n=400 000 000所需的时间差不多.\r\n由此可见,指数时间复杂度的算法太可怕…\r\n但是算法3对于n=400 000 000也几乎一瞬间就算完了.', '2016-02-16', '007', '3', '0', '0');
INSERT INTO `article` VALUES ('18', 'Twitter 的真正奥义', '人们往往很容易根据一个平台在初期时设计的某种功能和特性，去标定这个平台真正的价值——这是大部人都会犯的一个常见错误，比如，很多人会认为 Twitter 的价值在于 140 字符的限制。\r\n\r\n但 Twitter 的核心从来就不在于是 140 个字符的限制还是 150 个字符的限制，正如 Instagram 真正有价值的地方不在于正方形图片的限制一样——在上周，Instagram 宣布开始支持原始尺寸照片，它正式终结了自己一手缔造出来的正方形图片时代。\r\n\r\n我认为，社交平台真正的核心在于平台所形成的网络（Network）。这里的网络主要包括两部分：用户的关系网、关系网上存留的内容——这两部分组成会慢慢沉淀出一个信息市场（Info Marketplace），最终形成传播上的网络效应（Network Effect）。但在形成网络效应前，一个网络能成功搭建起来并且产生这两部分组成的重要前提是，拥有一个匹配的基础协议作支撑。这种基础协议通常体现在一个平台最初的架构设计上。\r\n\r\nImage title\r\n\r\nInstagram 有一个网络，Twitter 也有一个网络，每个社交平台都拥有自己的一个特定的网络——而整个互联网，你可以把它当成是全世界最大的一个非特定的通用型的社交平台：\r\n\r\n这个平台同时拥有最大的一个网络，基础协议是 TCP/UDP，他的关系网是全世界所有接入互联网的人，关系网上留存的内容是互联网上所有的信息，网络效应是互联网上的信息传播。因为是最 “大而泛” 的一个社交平台，这个平台拥有的网络——关系疏散、内容杂乱、网络效应很低。\r\n拿这套体系去解释 Instagram 去除正方形图片限制的逻辑会很有趣：\r\n\r\nInstagram 的使命是创造一个视觉性内容的分享平台；\r\n最初，Instagram 在基础架构里设计了一项正方形图片的限制功能，用这个功能去帮助自己更好的形成一个网络；\r\n通过标准化的正方形图片，Instagram 提升了用户的浏览速度，实现了图片快速消费，网络形成的速度也得到加快；\r\n当这个网络越变越大，大到最终超出了平台原有架构上设计的负载值——这时原本基础协议里构造出的正方形图片限制功能，反而成了阻止网络继续变大的障碍；\r\n这时去除掉这一功能，修正新的基础协议和架构设计以满足网络增长的需求，就是很自然的逻辑；\r\n当初 Instagram 决定在平台内引入视频内容和如今支持原始尺寸图片的逻辑是一样的。\r\n以同样的视角来看 Twitter：140 字符从来都不是 Twitter 的秘密武器，它真正具有独创性的核心价值在于网络底层的那套基础协议——也就是一个优美高效的公共通信协议（public messagingprotocol）。这个协议可以高效的运转信息，你把任何人写出的东西丢进这套协议构建出的网络里，都可以简单快速的把信息传达给其他人。Twitter 的本质就是一个公共通信协议。\r\n\r\n人们很难去具体描述 Twitter 这个平台的一个原因就在于，这样一个协议可以做的事情太多了。就像 Twitter、Instagram 都可以看作是架构在互联网上的一个特定应用，Twitter 这套公共通信协议有机会让 Twitter 这个平台成为另一个新的 “互联网”，下一代社交平台也许会成为架构在这个新 “互联网” 上的一个应用。也就是说，Twitter 平台会长出下一代的 Twitter 和 Instagram。\r\n\r\nImage title\r\n\r\n在社交平台上的基础上不断叠加出新的社交平台，就能不断演化出新的网络效应，网络效应又可以为人们提供新的功能和服务。Twitter 的本质是公共通信协议这件事，很容易让人联想到区块链技术——依靠区块链技术这种新型的通信协议，可以构造出一个共识网络，产生诸如比特币这样的应用。\r\n\r\n明确上面这几点之后，我们可以以此来思考一个问题：在 Instagram 去掉正方形图片限制之后，Twitter 也应该去掉 140 字符的限制吗？\r\n\r\n当社交平台拥有的网络体量需要进一步增大时，平台早期设计的协议和架构需要进一步作修改来满足扩容需求。但 Instagram 和 Twitter 最大的差别在于，图片消费相比 Twitter 上的短信息消费，对平台运作效率的敏感度来得低一些。换句话说，本质上是一个公共通信协议的 Twitter 比 Instagram 更需要讲究信息运作的效率。在传播上的高效和敏捷，是 Twitter 平台通过公共通信协议构建出的核心的网络效应。\r\n\r\n公共通信协议是平台早期架构设计的结果，这个架构在 Twitter 里可能包括了：\r\n\r\n平台的主信息流设计\r\n严格的年代反序时间轴设计\r\n粉丝和博主的关注机制的设计\r\n140 字符限制的设计\r\n……\r\n所以，虽然 Twitter 的法宝并不在于 140 字符的限制上，但 140 字符限制对于公共通信协议的影响毫无疑问是存在的——简单点说，140 字限制对 Twitter 来说不是核心，但也并非完全不重要。\r\n\r\n\r\n \r\n如果 Twitter 放弃了 140 字符的限制，很有可能平台能够承载的信息会变得更多更丰富，但传播的效率也有可能会下降，因为这种形态之下，整个信息流会变得更重，用户在单位时间里能看的信息数将会变少，进而影响到 Twitter 的网络效应。\r\n\r\n当我们在讨论 Twitter 要不要去掉 140 字符限制的时候，其实是在讨论怎样修改这套公共通信协议，以更好的增强 Twitter 平台的网络。', '2016-02-17', '001', '4', '0', '../uploadimg/1456299171.jpg');
INSERT INTO `article` VALUES ('19', '程序员必知-编程语言创始人', 'IT江湖根据TIOBE 编程语言排行榜（2015年4月）来介绍编程语言创始人，我们感谢这些人，为我们提供这些优秀的编程语言。\r\n\r\n程序员必知-编程语言创始人 - 第1张  | IT江湖\r\n\r\nC语言创始人\r\n程序员必知-编程语言创始人 - 第2张  | IT江湖\r\n\r\n丹尼斯·麦卡利斯泰尔·里奇（英语：Dennis MacAlistair Ritchie，1941年9月9日－2011年10月12日[3]），生于美国纽约州布朗克斯维尔（Bronxville），著名的美国计算机科学家，对C语言和其他编程语言、Multics和Unix等操作系统的发展做出了巨大贡献。在技术讨论中，他常被称为dmr，这是他在贝尔实验室的用户名称（username）。\r\n\r\nJava创始人\r\n程序员必知-编程语言创始人 - 第3张  | IT江湖\r\n\r\n詹姆斯·高斯林（英语：James Gosling，1955年5月19日－），出生于加拿大，软件专家，Java编程语言的共同创始人之一，一般公认他为“Java之父”。\r\n\r\n在他12岁的时候，他已能设计电子游戏机，帮忙邻居修理收割机。大学时期在天文系担任程式开发工读生，1977年获得了加拿大卡尔加里大学计算机科学学士学位。1981年开发在Unix上运行的Emacs类编辑器Gosling Emacs（以C语言编写，使用Mocklisp作为扩展语言）。1983年获得了美国卡内基梅隆大学计算机科学博士学位，博士论文的题目是：\"The Algebraic Manipulation of Constraints\"。毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司。1990年，与Patrick Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。1994年底，James Gosling在硅谷召开的“技术、教育和设计大会”上展示Java程式。2000年，Java成为世界上最流行的电脑语言。\r\n\r\nObjective-C语言创始人\r\n程序员必知-编程语言创始人 - 第4张  | IT江湖\r\n\r\n布莱德·考克斯（英语：Brad Cox），美国计算机科学家.\r\n\r\nC++语言的创始人\r\n程序员必知-编程语言创始人 - 第5张  | IT江湖\r\n\r\nBjarne Stroustrup博士，1950年出生于丹麦，先后毕业于丹麦阿鲁斯大学和英国剑挢大学，AT&T大规模程序设计研究部门负责人，AT&T 贝尔实验室和ACM成员。1979年，B. S开始开发一种语言，当时称为\"C with Class\"，后来演化为C++。1998年，ANSI/ISO C++标准建立，同年，B. S推出其经典著作The C++ Programming Language的第三版。）\r\n\r\nc#语言的创始人\r\n程序员必知-编程语言创始人 - 第6张  | IT江湖\r\n\r\n安德斯·海尔斯伯格（Anders Hejlsberg，1960年12月－），丹麦人，BorlandTurbo Pascal编译器的主要作者。进入微软公司后，先后主持了Visual J++、.Net和C#。\r\n\r\n出生于哥本哈根，安德斯·海尔斯伯格曾在丹麦技术大学学习工程，但没有毕业，大学时期他曾替Nascom microcomputer撰写程式，他曾为Nascom-2电脑撰写蓝标签（Blue Label）Pascal compiler，到了DOS时代他又重新改写这套compiler。当时他在丹麦拥有个叫Poly Data的公司，他编写了Compass Pascal编译器核心，后来叫Poly Pascal。1986年他首次认识了Philippe Kahn（Borland的创立者）。\r\n\r\nJavaScript语言创始人\r\n程序员必知-编程语言创始人 - 第7张  | IT江湖\r\n\r\n布兰登·艾克（英语：Brendan Eich，1961年－，美国程序员与企业家，JavaScript主要创造者与架构师，曾任Mozilla公司首席首席技术官。\r\n\r\n\r\n \r\n布兰登·艾克生于美国加州的森尼维尔市，在圣塔克拉拉大学（Santa Clara University）就读时，最初主修物理学，在大三时，因兴趣转变，投入计算机科学领域，后获取数学与计算机科学学士学位。1986年获取伊利诺伊大学香槟分校计算机科学硕士学位。\r\n\r\n毕业后进入SGI工作，在此工作七年，主要负责操作系统与网络功能。之后他至MicroUnity工作了三年。\r\n\r\n1995年4月4日，任职于网景期间，为网景浏览器开发出JavaScript，之后成为浏览器上应用最广泛的脚本语言之一。\r\n\r\n1998年，布兰登协助成立Mozilla.org，2003年在美国在线决定结束网景公司营运后，布兰登协助成立了Mozilla基金会。\r\n\r\n感谢这些作者', '2016-02-18', '007', '8', '0', '0');
INSERT INTO `article` VALUES ('20', '我们搞开发的为什么会感觉到累', '引题\r\n昨天下班坐公车，听到一个和我年纪相仿的哥们儿打电话，隐约听到电话那边好像是他女朋友问他现在饿不饿，他说“我已经饿的不饿啦”。\r\n\r\n饿的不饿了，听起来很幽默，对我很有触动，我在思考，我此时站在公车中部，手扶着杆有点酸，你问我手有多酸，借用打电话的那个哥们的话，随着日复一日这样的酸痛感受的反复刺激，已经酸的不酸了，你问我饿不饿，我也说不上来，飘飘渺渺，因为做编程这行几年下来，我自己的感受是，虽到了吃饭时间，但是感觉似饿非饿，吃饭感觉只是个形式。\r\n\r\n以上都是是大多数在一线城市奋斗的人们所经历的可以忽略不计的一些事，我这里想聊聊为什么我们做IT的大多数都很累？\r\n\r\n什么叫累，古代私塾先生教书的时候解释说，累字拆分意义是田系在头上，白话文讲就是“头上有田方知累也”。这是上古时代“累”的含义，当然现在还有大多数人为了我们国家的发展在辛勤劳累的种田，他们很辛苦。\r\n\r\n我们的累\r\n回到标题，我觉得我门做编程的大多数人都很累，为什么累呢？\r\n\r\n到一个新公司上班，公司预先说要做一个项目或产品，你不知道到底有多复杂或简单，心里些许担心或不安，因为这些东西有可能在你预想的基础上会变的。\r\n准备启动项目或产品，开始做需求，由于老板把时间压得紧，需求可能有些粗糙，开发时间也被压很短，因为这样，担心和紧张感铺面而来，需求会不会变，会不会遇到技术障碍，都是可变的。\r\n开发过程中，由于需求做的不够精细（这太正常了，客户或老板都不知道他要什么），接二连三的变动和更改，紧张万分，不知道哪一会儿会又变动。\r\n累死累活做完了，开始测试了，啊，XXX这里点击没反应，邮件怎么没发送成功，怎么发送成功了没收到，又报黄页，js错误……时刻有可能出bug。\r\n终于上线了，客户出了个error，你帮忙看看吧（测试阶段都没有这问题哦）；日志记录了不少错误哦，你给定位下；客户投单没成功，肯定他妈的第三方接口问题；客户IE6下按钮点不了，下拉框出不来；oh shit ……\r\n又开始新的项目了，新的一轮紧张挑战拉开帷幕……之前上线的项目或产品还会时不时给你来些心跳，下一秒未可知，明天未可知。\r\n循环ing……\r\n大伙可能要说担心或不安是多余的，那是你技术水平太垃圾吧，我之前的技术leader技术很好，很牛逼，平常他说的最多的是未雨绸缪，居安思危，人无远虑必有近忧这些句话。他时常会研究新东西，新技术，给我们安排好书去读让我们保持进步，说实话过程中有点反感但从中受益。\r\n\r\n有时候我们自己需要被迫去变，因为现在大的背景变化非常大，PC向移动的迁移，时刻在变，我们也时刻因为这些变而被动变，或被这些变影响我们的生活，苹果开发初级10k左右起，直接秒了我们大部分搞了3年左右.net或java的人，听过好多身边做pc开发的都呐喊过说想变，但是真正主动承受痛苦去变成功的没多少人。\r\n\r\n有的人可能会说了，赶紧努力吧，做管理，当领导，呵呵，我发现那些大部分位置越高的人头发越稀落，医学上说头发稀落和肾功能衰弱有关，常言道，恐伤肾，可想是担受了多少惊恐与变数，过几年你很有可能就成了他们。中层领导有来自高层的压力，高层来自boss的压力，boss来自生存的压力和股东投资者的压力等……有时候麻雀没有变成凤凰未尝不是一种解脱啊，我说这话你可以说我是个loser思维，我也诚然。我想告诉大家的是珍惜当下吧！我现在特别怀念刚参加工作那会儿，激情，敢说敢做，敢表现神经质……\r\n\r\n所以说，我们累是因为我们所从事的事情变数很多，人最恐惧未来，因为未来不可知，上至诸侯王下至编户百姓无一幸免，我们就活在这样变化无常的区域里面，紧张嘻嘻，正是这样，久而久之变得抑郁，神经衰弱，麻木不仁，懒得动，懒得说话……恶性循环。\r\n\r\n我们现在就是忙于应付这些变，所以搞的自己紧张忙碌，最终却没多大所获。这是我们大多数人的现状。\r\n\r\n\r\n \r\n新生\r\n希望2015大伙都少些加班，把有限的业余时间拿来好好放松自己，勤跑步，多看书，充实自己，做到可持续发展，主动改变自己，无论您今年多大了都应该充满理想，因为中国历史上历来不缺少枯木逢春、老来发迹的例子。大器晚成的人他没有年少轻狂，没有少不更事；年轮的重叠使他们更加珍视机遇，岁月的磨砺让他们事事洞明、人情练达。我希望大伙都能达到自己的理想，并且在很嫩的时候。\r\n\r\n最后，关于加班我讲个小故事，希望能影响到一点点正在加班的同胞们，故事名字叫奴性是怎样练成的：第1天抽他100鞭子，他很愤怒但没敢说；第2天抽他80鞭子，他看到了生活的希望；第3天抽他50鞭子，他夸抽他的人进步了；第4天抽了他30鞭子，他跪下感动流涕；第5天抽他了20鞭子，他感恩戴德；第6天7天他已习惯了在感动中挨鞭子。并开始用鞭子抽那些同情他的人。', '2016-02-19', '001', '2', '0', '0');
INSERT INTO `article` VALUES ('21', '10个迹象表明程序员编码太久了', '1.无法控制自己不去想代码\r\n如果你的大脑已经开始在各种错误的时间错误的地方，不由自主地插播代码，那么说明，你的编码时间真心太久了。\r\n\r\n“做梦梦见敲代码。”Joachim van de Haterd\r\n\r\n“发短信的时候，情不自禁地开始用代码表达意思。”Alafazam Khan\r\n\r\n“梦见调试代码。”Muzaffar Ali\r\n\r\n“甚至洗澡的时候，还在想着代码。”Pete Pirasis\r\n\r\n2.时间犹如白骏过隙，刹那而逝\r\n如果你只顾蒙头写代码，完全意识不到时间的流逝，那么说明，你的编码时间真心太久了。\r\n\r\n“我抬头看窗外，发现居然天都已经亮了。”Sam Couch\r\n\r\n“白天和黑夜根本没有什么分别。眼中只有代码，代码，代码。“agent Smith\r\n\r\n3.开始只会计算2的幂\r\n如果你所有东西都开始用二进制数字来计算的话，那么说明，你的编码时间真心太久了。\r\n\r\n“四舍五入的数值是1024！”Pritesh Soni\r\n\r\n“……在你的思维中，整数指的是2的幂，而不是10。”Anonymous\r\n\r\n“有一次我去商店买1千克的大米，发现店主少给了我24克。”Utkarsh Simha\r\n\r\n4.习惯于使用驼峰拼写法\r\n如果你发现自己开始在一些并非变量、函数、方法、类等等编程事件上面使用驼峰拼写法的话，那么说明，你的编码时间真心太久了。\r\n\r\n“比如说，你开始这样写字StartWritingQuoraAnswers。”Sharath Gm\r\n\r\nMcDonalds（麦当劳）写成mCdonalds\r\n\r\n5.语言出现问题\r\n如果你发现你的母语甚至还不如你使用的编程语言顺溜，那么说明，你的编码时间真心太久了。\r\n\r\n“在与人交流的时候，母语语法开始出错。”Phil Darnowsky\r\n\r\n“开始混淆常用英语单词与编程术语:)”Anonymous\r\n\r\n6.从0开始计数\r\n如果你什么都开始从0算起，那么说明，你的编码时间真心太久了。\r\n\r\n“在排序中第一项找的不是No.1，而是No.o。”Nurul Quamar Khan\r\n\r\n“从0计数，而不是1。”Tapasweni Pathak\r\n\r\n“点算的时候：0,1,2,3,4,5,6,7,8,9，A，B，…”TheOne\r\n\r\n7.开始在生活中注释标记\r\n如果你发现自己居然试图给一些普通文件标记注释——甚至是一些日常对话，那么说明，你的编码时间真心太久了。\r\n\r\n“不知不觉地就会使用‘//’写注释。”Rajarsi Chattopadhyay\r\n\r\n“即使是在与别人闲聊，也会使用‘//’写注释。”Kaushik Gopalan\r\n\r\n8.在现实生活中使用键盘快捷方式\r\n当你开始在一些没有编辑器也没有代码的情况下，尝试使用一些惯用的编程快捷方式时，那么说明，你的编码时间真心太久了。\r\n\r\n“会键入‘：wq’或者‘：q’用来关闭浏览器的标签。”Prajwal Yadapadithaya\r\n\r\n“……具体到UNIX：敲下一个不完整的名字，很顺手地就按下了Tab键。”Utkarsh Sharma\r\n\r\n“在阅读书籍的时候，想要查找内容，不由自主地会想用Ctrl+ F。”Cabriel Turkadze\r\n\r\n“惹女朋友生气了，脑袋中蹦出的第一个念头是‘Ctrl+ Z’。”Gaurav Kumar Singh\r\n\r\n9.使用计算机中的编程符号和计算符\r\n如果你在现实世界中开始使用特定的程式计算符，那么说明，你的编码时间真心太久了。\r\n\r\n\r\n \r\n“不小心在支票上写错了日期，立马加上‘++’来修复这个问题。”Tom Howard\r\n\r\n“开始在一些正常谈话中使用==代替=。”Neha Dubey\r\n\r\n“当我帮我的侄子应付一篇家庭作业文章时，他问我为什么我每句话的末尾要用分号，而不是句号。”Surjit Raghunath\r\n\r\n10.做一些在非程序员看来莫名其妙完全不能理解的事情\r\n如果你开始做一些莫名其妙非常奇怪的事情，那么说明，你的编码时间真心太久了。', '2016-02-20', '002', '2', '0', '0');
INSERT INTO `article` VALUES ('22', '程序员必读的六本书', '作为一名程序员，日常的工作除了上班撸代码就是加班撸代码了。撸码其实不难，无非询问Google，StackOverflow，解决方法和demo一箩筐，可是撸的一手好代码着实不易。无独有偶，码农一抓一大把，优秀的程序员却不易寻觅。优秀的程序员既不可能出自各种天花乱坠的培训机构，更不可能来自挖掘机摇篮山东布鲁斯特，大多数优秀的程序员有一个共同点，那就是自学。\r\n\r\n为什么是自学呢？首先大学的教育不可能让你成为专家级别的程序员，其次为了能从团队脱颖而出必然付出更多的努力来学习。自学其实是一种很强有力的能力，一旦掌握，许多技术和问题都可以轻松搞定。\r\n\r\n中学物理常客牛顿曾说，”如果我比别人看得更远，那是因为我站在巨人的肩上“。他山之石，可以攻玉。阅读大师巨匠的作品无疑是最有效的自学方式之一。业界知名的Bob大叔是代码整洁和面向对象编程的坚定支持推进者，其在这方面的著作可以称得上权威。Martin Fowler同样名声在外，他的关于重构的著作《重构—-改善既有代码的设计》应该是人手一本。阅读诸如上面两位大家的著作，对技术提到大有裨益。\r\n\r\n本文讲列举六本业界牛人的著作，也是编程书籍中经典的经典，这几本书并非简单的教程书籍，而是教给你方法和思想来解决现实遇到的问题，提高编码的技艺和境界。\r\n\r\n重构—-改善既有代码的设计\r\n何为重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。本书虽然使用Java语言书写示例代码，但是其概念与思想同样适合于其他语言。书中，作者以一些平淡无奇，甚至带有坏味道的代码开始，一步一步地修改转变成更加灵活，可重用的代码。通过书中的示例，你会清楚地明白什么才是整洁的代码。重构其实依然成为经验丰富的程序员的必备技能，当你想要改善重构代码时，读一读这本书就会让你有章可循，豁然开朗。\r\n查看详细：亚马逊\r\n\r\n代码整洁之道\r\n这是我最喜欢的一本书，不止一次我将它推荐给我的同事，读者还有学生。我认为它可以称得上软件开发与编码方便最好的一本书。Bob大叔我想无需做介绍，他写过一个关于敏捷开发的系列书籍，我的书架上就有他的《代码整洁之道》,《程序员的职业素养》，《敏捷软件开发(原则模式与实践)》，《敏捷软件开发(原则模式与实践)》，《UML for Java For Programmers》， 《Extreme Programming in Practice》等这些书籍。虽然他的这些书有点老旧，但是这些书仍然很有价值，纵使数十年之后，这些书依旧受用，尤其是在面向对象编程方面。 本书不仅仅是告诉你要做什么，还教会你什么不能做。书中有关于代码味道的一个章节，全面列举了大多数程序员遇到的各种错误，其后的章节则详细描述如何纠正这些错误。比如如何将过长的switch声明转换成遵循开放闭合原则的模型，如何利用集成和多态。再次啰嗦一下，这本书确实值得每个程序员拥有。和上本书一样，书中的例子使用Java语言，但依然适合使用其他面向对象编程语言的开发者阅读。想要撸的一手好码，这本书必不可少。\r\n查看详细:亚马逊\r\n\r\n代码大全\r\n\r\n\r\n想必这本书大家都曾阅读过，这就是鼎鼎大名的《代码大全》，从某个角度看，它其实就是C++版的《代码整洁之道》。本书的目标就是帮开发者使用做高质的代码写出更好的软件。同样书中也涉及了编程中常见问题和最佳实践。这本书也可以称得上是必读书籍，尤其是对于C和C++程序员。《代码大全(第2版)》中所论述的技术不仅填补了初级与高级编程实践之间的空白，而且也为程序员们提供了一个有关软件开发技术的信息来源。《代码大全(第2版)》对经验丰富的程序员、技术带头人、自学的程序员及没有太多编程经验的学生都是大有裨益的。可以说，只要你具有一定的编程基础，想成为一名优秀的程序员，阅读《代码大全(第2版)》都不会让你失望。\r\n查看详细:亚马逊\r\n\r\n单元测试的艺术\r\n如果非要做一件改善项目，提高开发者水平的事情，我想那就是让开发者掌握单元测试的能力。对于专业的开发者来说，单元测试是一项必备的技能，多数的程序员却不具备TDD（测试驱动开发）的能力。我虽然在不太遵循TDD这种模式，但是也会为自己写的或维护的代码编写单元测试。对于工程来说，开源项目基本都严格遵守执行单元测试，而很多商业的工程则在单元测试方面有所缺失。一个拥有单元测试的项目会变得更加容易维护和更改。本书会介绍成功的项目与失败项目的差别，可维护的代码库与不可维护的代码库之间的区别。本书示例为.NET代码，但这并不会影响你了解单元测试。如果你是一名技术负责人或者项目负责人，这本书可以帮你更好地把控项目代码质量。如果你看Java更舒服的话，也可以看一看这本书《JUnit实战(第2版)》。\r\n查看详细:亚马逊\r\n\r\n精益软件开发管理之道\r\n《精益软件开发管理之道》是一本软件开发方法学的书。作者从24个不同的视角，在更大的空间、时间、行业、文化背景下，考察了敏捷和精益方法。《精益软件开发管理之道》详细阐述了敏捷和精益开发方法取得成功的深层原因。《精益软件开发管理之道》包括以下内容：系统思考，以适当足够的方式关注客户；技术杰出，介绍了杰出软件开发的基础-低耦合的架构、测试驱动的开发过程等；可靠交付，讨论了工作流和日程计划，以及反馈的重要作用；无情改进，讨论了所有精益组织的基本特点：持续不断、永不满足的改进；卓越的人，卓越的结果来自于卓越的人；一致的领导，讨论在领导团队中达成一致。\r\n查看详细：亚马逊\r\n\r\n\r\n \r\n设计模式 可复用面向对象软件的基础\r\n这本书要么你读过，要么就是听说过，这就是经典的GOF（Gang of Four 中文译为四人帮）设计模式一书。该书作者为四人，分别是Eric Gamma, Richard Helm, Ralph Johnson, 和John Vissides。四位顶尖的面向对象领域专家精心选取了最具价值的设计实践，加以分类整理和命名，并用简洁而易于重用的形式表达出来。本书已经成为面向对象技术人员的圣经和词典，书中定义的23个模式逐渐成为开发界技术交流所必备的基础知识和语汇。使用这些设计模式，我们可以设计出灵活，优雅和可重用的可扩展的设计。\r\n查看详细：亚马逊\r\n\r\n \r\n\r\n颈椎病康复指南\r\n最新更新，原文不包含本书，应读者评论要求，特意加入此书。\r\n\r\n写代码不仅是头脑的工作，更是体力的付出。长年累月，身体必然出现问题。脂肪肝，脊椎病等等。希望这本书可以给你脊椎病恢复提供指导。\r\n查看详细：亚马逊', '2016-02-24', '002', '2', '0', '../uploadimg/1456299146.jpg');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `cid` int(8) unsigned NOT NULL AUTO_INCREMENT COMMENT '评论编号',
  `aid` int(8) NOT NULL COMMENT '文章编号',
  `name` varchar(25) NOT NULL COMMENT '用户名',
  `mail` varchar(25) NOT NULL COMMENT '邮箱',
  `content` varchar(255) NOT NULL COMMENT '评论内容',
  `time` char(14) NOT NULL,
  PRIMARY KEY (`cid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------

-- ----------------------------
-- Table structure for terms
-- ----------------------------
DROP TABLE IF EXISTS `terms`;
CREATE TABLE `terms` (
  `term_id` int(3) unsigned zerofill NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `name` varchar(255) NOT NULL COMMENT '分类名',
  PRIMARY KEY (`term_id`,`name`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of terms
-- ----------------------------
INSERT INTO `terms` VALUES ('001', '未分类');
INSERT INTO `terms` VALUES ('002', '日记');
INSERT INTO `terms` VALUES ('003', '前端汇总');
INSERT INTO `terms` VALUES ('004', '后端汇总');
INSERT INTO `terms` VALUES ('005', '编程工具');
INSERT INTO `terms` VALUES ('006', '信息安全');
INSERT INTO `terms` VALUES ('007', '文章收藏');
INSERT INTO `terms` VALUES ('008', '读书笔记');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `username` varchar(20) NOT NULL COMMENT '用户名',
  `password` varchar(20) NOT NULL COMMENT '用户密码',
  `motto` varchar(50) NOT NULL COMMENT '个性签名',
  `address` varchar(50) NOT NULL COMMENT '现居',
  `profession` varchar(10) NOT NULL COMMENT '职业',
  `hobby` varchar(20) NOT NULL,
  `experience` mediumtext NOT NULL,
  `ilogo` varchar(255) NOT NULL,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('904509221', '904509221', '我们不停的翻弄着回忆,却再也找不回那时的自己,红尘一梦，不再追寻。—————无名', '中国—重庆市', '学生', '《红楼梦》', '在这物欲横流的人世间，人生一世实在是够苦。你存心做一个与世无争的老实人吧，人家就利用你欺侮你。你稍有才德品貌，人家就嫉妒你排挤你。你大度退让，人家就侵犯你损害你。你要不与人争，就得与世无求，同时还要维持实力准备斗争。你要和别人和平共处，就先得和他们周旋，还得准备随时吃亏。\r\n　　少年贪玩，青年迷恋爱情，壮年汲汲于成名成家，暮年自安于自欺欺人。\r\n　　人寿几何，顽铁能炼成的精金，能有多少？但不同程度的锻炼，必有不同程度的成绩；不同程度的纵欲放肆，必积下不同程度的顽劣。\r\n　　上苍不会让所有幸福集中到某个人身上，得到爱情未必拥有金钱；拥有金钱未必得到快乐；得到快乐未必拥有健康；拥有健康未必一切都会如愿以偿。 \r\n　　保持知足常乐的心态才是淬炼心智，净化心灵的最佳途径。一切快乐的享受都属于精神，这种快乐把忍受变为享受，是精神对于物质的胜利，这便是人生哲学。\r\n　　一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。\r\n　　我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……\r\n　　我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。', '../uploadimg/1456243410.jpg', 'Slane');
